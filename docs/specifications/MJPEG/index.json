[
    ["h1","MJPEG"],
    ["p","Safari can play 1920Ã—1080 Motion JPEG-A at 30 FPS on M1 Mac."],
    ["p","Convert JPEG to MOV by ",["a",{"href":"https://github.com/mizt/MultiTrackQTMovie"},"MultiTrackQTMovie"],"."],
    ["pre",["code","#import <Foundation/Foundation.h>\n#import \"MultiTrackQTMovie.h\"\n\nint main(int argc, char *argv[]) {\n\t@autoreleasepool {\n\t\tunsigned int TRACK_ID = 0;\n\t\tstd::vector<MultiTrackQTMovie::TrackInfo> info;\n\t\tinfo.push_back({.width=1920,.height=1080,.depth=24,.fps=30.,.type=\"jpeg\"});\n\t\tMultiTrackQTMovie::Recorder *recorder = new MultiTrackQTMovie::Recorder(@\"test.mov\",&info);\n\t\t\tfor(int k=0; k<30; k++) {\n\t\t\t\tNSData *image = [[NSFileManager defaultManager] contentsAtPath:[NSString stringWithFormat:@\"%05d.jpg\",k]];\n\t\t\t\trecorder->add((unsigned char *)[image bytes],(unsigned int)[image length],TRACK_ID);\n\t\t\t}\n\t\trecorder->save();\n\t}\n}"]],
    ["p","Build libjpeg-turbo",["br"],["a",{"href":"https://github.com/libjpeg-turbo/libjpeg-turbo/issues/250"},"https://github.com/libjpeg-turbo/libjpeg-turbo/issues/250"]],
    ["pre",["code","git clone https://github.com/libjpeg-turbo/libjpeg-turbo.git\ncd ./libjpeg-turbo\nemcmake cmake -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release -DWITH_SIMD=0 .\nmake"]],
    ["p","C++"],
    ["pre",["code","#import \"turbojpeg.h\"\n#import \"MultiTrackQTMovieParser.h\"\nMultiTrackQTMovie::Parser *parser = nullptr;\nconst int TRACK_ID = 0;\nunsigned char *buffer = nullptr;\n\nextern \"C\" {\n\n\tEMSCRIPTEN_KEEPALIVE int length() {\n\t\tif(parser) {\n\t\t\treturn parser->length(TRACK_ID);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tEMSCRIPTEN_KEEPALIVE int width() {\n\t\tif(parser) {\n\t\t\treturn parser->width(TRACK_ID);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tEMSCRIPTEN_KEEPALIVE int height() {\n\t\tif(parser) {\n\t\t\treturn parser->height(TRACK_ID);\n\t\t}\n\t\treturn 0;\n\t}\n\n\tEMSCRIPTEN_KEEPALIVE int decodeJPEG(unsigned char *dst, int w, int h, unsigned char *bytes, int length) {\n\t\tint width;\n\t\tint height;\n\t\tint subsample;\n\t\tint colorspace;\n\t\ttjhandle handle = tjInitDecompress();\n\t\tif(!tjDecompressHeader3(handle,bytes,length,&width,&height,&subsample,&colorspace)) {\n\t\t\tif(width==w&&height==h) {\n\t\t\t\tif(subsample==0) {\n\t\t\t\t\ttjDecompress2(handle,bytes,length,buffer,width,0,height,TJPF_RGB,TJFLAG_FASTDCT);\n\t\t\t\t}\n\t\t\t\telse if(subsample==2) {\n\t\t\t\t\tunsigned char *yuv420 = new unsigned char[tjBufSizeYUV(width,height,subsample)];\n\t\t\t\t\ttjDecompressToYUV(handle,bytes,length,yuv420,TJFLAG_FASTDCT);\n\t\t\t\t\ttjDecodeYUV(handle,yuv420,1,subsample,buffer,width,0,height,TJPF_RGB,0);\n\t\t\t\t\tdelete[] yuv420;\n\t\t\t\t}\n\t\t\t\tif(buffer) {\n\t\t\t\t\tunsigned int *argb = (unsigned int *)dst;\n\t\t\t\t\tfor(int i=0; i<height; i++) {\n\t\t\t\t\t\tfor(int j=0; j<width; j++) {\n\t\t\t\t\t\t\tint addr = (i*width+j)*3;\n\t\t\t\t\t\t\targb[i*width+j] = 0xFF000000|buffer[addr+2]<<16|buffer[addr+1]<<8|buffer[addr+0];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\ttjDestroy(handle);\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\ttjDestroy(handle);\n\t}\n\n\tEMSCRIPTEN_KEEPALIVE int update(unsigned char *dst, int frame) {\n\t\tif(parser&&frame<parser->length(TRACK_ID)) {\n\t\t\tunsigned long long offset = 0;\n\t\t\tunsigned int size = 0;\n\t\t\tint width = parser->width(TRACK_ID);\n\t\t\tint height = parser->height(TRACK_ID);\n\t\t\tif(parser->get(frame,TRACK_ID,&offset,&size)) {\n\t\t\t\tif(decodeJPEG((unsigned char *)dst,width,height,parser->bytes()+offset,size)) {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn 0;\n\t}\n\t\n\tEMSCRIPTEN_KEEPALIVE int setup(unsigned char *mov, int length) {\n\t\tif(parser==nullptr) {\n\t\t\tparser = new MultiTrackQTMovie::Parser(mov,length);\n\t\t\t\tif(parser) {\n\t\t\t\t\tif(buffer) delete[] buffer;\n\t\t\t\t\tbuffer = new unsigned char[parser->width(TRACK_ID)*parser->height(TRACK_ID)*3];\n\t\t\t\t}\n\t\t}\n\t\treturn (parser)?1:0;\n\t}\n\n}"]],
    ["p","Build (Emscripten)"],
    ["pre",["code","em++ -O3 -std=c++17 -Wc++17-extensions --memory-init-file 0 -s TOTAL_MEMORY=98304000 -s VERBOSE=1 -s ASSERTIONS=1 -s WASM=0 -s EXPORTED_FUNCTIONS=\"['_malloc','_free']\" -s EXPORTED_RUNTIME_METHODS=\"['cwrap']\" -L ./ -lturbojpeg -I ./ main.cpp -o ./libs.js"]],
    ["p","Decode JPEG in JavaScript"],
    ["pre",["code","fetch(\"test.mov\").then((response)=>{\n\tif(response.ok) {\n\t\treturn response.arrayBuffer();\n\t}\n\telse {\n\t\tthrow new Error(response.status);\n\t}\n}).then((data)=>{\n\tconst bytes = new Uint8Array(data);\n\tconst data = new U8(MOV.bytes.length);\n\tdata.buffer.set(bytes);\n\tif(Module.cwrap(\"setup\",\"number\",[\"number\",\"number\"])(data.buffer.byteOffset,data.length)) {\n\t\tconst width = Module.cwrap(\"width\",\"number\",[])();\n\t\tconst height = Module.cwrap(\"height\",\"number\",[])();\n\t\tconst totalFrames = Module.cwrap(\"length\",\"number\",[])();\n\t\tconst src = new U8((MOV.width*MOV.height)<<2);\n\t\tif(Module.cwrap(\"update\",\"number\",[\"number\",\"number\"])(src.buffer.byteOffset,0)) {\n\n\t\t}\n\t}\n};"]]
    
]
